// Copyright (c) 2019 - 2022 RacoonStudios

/*
This vertex shader also passes through a view space ray used for view space position reconstruction.
Without it reconstructing the view space position would be more expensive by using the clip space to view space matrix as follows:

float3 GetViewSpacePositionByScreenSpacePosition(float2 screenSpacePosition, float depth)
{
	// API coordinate system related differences
	@property(UpperLeftOrigin)
		screenSpacePosition.y = 1.0f - screenSpacePosition.y;
	@end
	@property(!ZeroToOneClipZ)
		// 0..1 -> -1..1
		depth = depth * 2.0f - 1.0f;
	@end

	// Get x/w and y/w from the screen space position
	float x = screenSpacePosition.x * 2.0f - 1.0f;
	float y = screenSpacePosition.y * 2.0f - 1.0f;
	float4 projectedPosition = float4(x, y, depth, 1.0f);

	// Get view-space position
	float4 inversePosition = MATRIX_MUL(PassData.ClipSpaceToViewSpaceMatrix, projectedPosition);
	return inversePosition.xyz / inversePosition.w;
}

For more background formation regarding reconstructing position from depth please have a look at:
- "The Danger Zone" - "Scintillating Snippets: Reconstructing Position From Depth" - "Written by MJPMarch 10, 2009" - https://mynameismjp.wordpress.com/2009/03/10/reconstructing-position-from-depth/
- "The Danger Zone" - "Reconstructing Position From Depth, Continued" - "Written by MJPMay 5, 2009" - https://mynameismjp.wordpress.com/2009/05/05/reconstructing-position-from-depth-continued/
- "The Danger Zone" - "Position From Depth 3: Back In The Habit" - "Written by MJPSeptember 5, 2010" - https://mynameismjp.wordpress.com/2010/09/05/position-from-depth-3/
*/


//[-------------------------------------------------------]
//[ Definitions                                           ]
//[-------------------------------------------------------]
@includepiece(../Shared/SP_Core.asset)
	@insertpiece(SetCrossPlatformSettings)


//[-------------------------------------------------------]
//[ Input / output                                        ]
//[-------------------------------------------------------]
// Attribute input / output
INPUT_BEGIN
	INPUT_VERTEX_ID
INPUT_END
OUTPUT_BEGIN
	OUTPUT_TEXTURE_COORDINATE(1, float2, TexCoordVS, 0)	// Texture coordinate
	OUTPUT_TEXTURE_COORDINATE(2, float3, ViewRayVS,  1)	// View space ray used for view space position reconstruction
	OUTPUT_POSITION			 (0)						// Clip space vertex position as output, left/bottom is (-1,-1) and right/top is (1,1)
OUTPUT_END

// Uniform buffers
struct PassDataStruct
{
	float4 ViewSpaceFrustumCorners[4];
};
UNIFORM_BUFFER_BEGIN(0, 0, PassUniformBuffer, 0)
	PassDataStruct PassData;
UNIFORM_BUFFER_END


//[-------------------------------------------------------]
//[ Main                                                  ]
//[-------------------------------------------------------]
MAIN_BEGIN
	// Clip space vertex positions of the full screen triangle, left/bottom is (-1,-1) and right/top is (1,1)
	//								Vertex ID	Triangle on screen
	//	-1.0f,  1.0f, 0.0f, 0.0f,	0			  0.......1
	//	 3.0f,  1.0f, 2.0f, 0.0f,	1			  .   .
	//	-1.0f, -3.0f, 0.0f, 2.0f	2			  2
	// For background information about the attribute-less fullscreen triangle rendering see "An interesting vertex shader trick" by Cort Stratton
	// talking about the vertex shader of Timothy Lottes' Fast Approximate Anti-Aliasing algorithm (FXAA) - https://web.archive.org/web/20140719063725/http://www.altdev.co/2011/08/08/interesting-vertex-shader-trick/#sthash.yVnXrYGi.dpuf

	// Transform the object space vertex into clip space
	MAIN_OUTPUT_POSITION = float4(CAST_TO(MAIN_INPUT_VERTEX_ID % 2, float) * 4.0f - 1.0f, CAST_TO(MAIN_INPUT_VERTEX_ID / 2, float) * 4.0f - 1.0f, 0.0f, 1.0f);
	@property(!UpperLeftOrigin)
		MAIN_OUTPUT_POSITION.y = -MAIN_OUTPUT_POSITION.y;
	@end

	// Pass through the texture coordinates
	MAIN_OUTPUT(TexCoordVS) = float2(CAST_TO(MAIN_INPUT_VERTEX_ID % 2, float) * 2.0f, 1.0f - CAST_TO(MAIN_INPUT_VERTEX_ID / 2, float) * 2.0f);

	// Pass through the view space ray used for view space position reconstruction
	MAIN_OUTPUT(ViewRayVS) = PassData.ViewSpaceFrustumCorners[MAIN_INPUT_VERTEX_ID].xyz;
MAIN_END
